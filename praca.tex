\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{float}

\input{pygments}

\providecommand{\imref}[1]{Rys. \ref{#1}} % referencja do obrazka

%% Define a new 'leo' style for the package that will use a smaller font.
\makeatletter
\def\url@leostyle{
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%% Now actually use the newly defined style.
\urlstyle{leo}

\newfloat{listing}{thp}{lol}
\floatname{listing}{Listing}

\begin{document}

\author{Jakub Kuźma}
\title{Pioneers - internetowa implementacja gry ,,Osadnicy z Catanu''
  w oparciu o framework Ruby on Rails}
\date{\today}

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents

\clearpage

\section{Analiza zagadnienia}

\subsection{Osadnicy z Catanu}
Gra planszowa ,,Osadnicy z Catanu'' została stworzona przez
niemieckiego matematyka Klausa Teubera. Po raz pierwszy została ona
wydana w 1995 roku w Niemczech pod nazwą \emph{Die Siedler von
  Catan}. O ogromnej popularności gry na całym świecie może świadczyć
fakt, iż została ona przetłumaczona na ponad 20 języków, w tym język
polski. Na całym świecie organizowane są turnieje gry, a począwszy od
roku 2000 organizowane są corocznie mistrzostwa świata. Pierwsze
polskie wydanie gry przypada na rok 2005. Od tego czasu każdego roku
organizowane są Mistrzostwa Polski w grze ,,Osadnicy z Catanu'', które
w 2009 roku odbędą się w Gliwicach.

\subsection{Elementy gry}
Pierwotna wersja gry jest przeznaczona dla 3-4 graczy. Słowo
,,pierwotna'' jest tutaj szczególnie warte podkreślenia, gdyż, ze
względu na swą ogromną popularność, gra doczekała się bardzo dużej
ilości dodatków i modyfikacji zasad. W tym podrozdziale postaram się
omówić wszystkie elementy wchodzące w skład podstawowej wersji
gry. Jednakże, moim celem nie jest tłumaczenie zasad gry, a jedynie
ukazanie najważniejszych jej aspektów, które musiały zostać
uwzględnione przy implementacji.

\subsubsection{Plansza}
Rozgrywka toczy się na planszy złożonej z 37 sześciokątów
oznaczających różne rodzaje terenu oraz przypisanych do nich wartości
liczbowych. Poszczególne rodzaje pól mogą mieć także określony rodzaj
surowca, który może być z nich czerpany:

\begin{itemize}
\item las - drewno
\item pastwisko - wełna
\item pole uprawne - zboże
\item wzgórze - glina
\item góry - ruda żelaza
\item pustynia - brak surowca (początkowe położenie ,,rozbójnika'')
\item morze - brak surowca (może posiadać szlak handlowy)
\end{itemize}

Elementami planszy są również krawędzie i wierzchołki połączonych
sześciokątów. Na wierzchołkach (skrzyżowaniach) gracze mogą budować
osady i miasta. Przynoszą one dochód w postaci surowców z
sąsiadujących z nimi sześciokątów. Krawędzie natomiast przeznaczone są
pod budowę dróg, które łączą osady i miasta. Drogi nie przynoszą
żadnych dochodów, umożliwiają natomiast ekspansję terytorialną
(budowanie nowych osad).

Wszystkie karty surowców znajdujące się w posiadaniu poszczególnych
graczy są zakryte dla pozostałych uczestników gry.

\subsubsection{Element losowy - kości do gry}
Gra ,,Osadnicy z Catanu'' jest grą umysłowo-losową. Głównym elementem
wprowadzającym do gry losowość są dwie sześciościenne kości do
gry. Dla sumy dwóch rzutów kością prawdopodobieństwo uzyskania
poszczególnych wyników jest różne (zostało to przedstawione na
\imref{dice}). Sześciokąty na planszy (lasy, pastwiska, pola uprawne,
wzgórza i góry) mają przypisane wartości z przedziału 2-12, z
pominięciem liczby 7. Wszyscy gracze przed rozpoczęciem swojej tury
wykonują rzut kośćmi. Wynik rzutu oznacza, które sześciokąty przynoszą
w danej turze dochód. Surowce otrzymują tylko ci gracze, którzy są
posiadaczami osady lub miasta, które sąsiaduje z wylosowanym
sześciokątem. Przypisana wartość i rodzaj pola mają bezpośredni wpływ
na jego ,,atrakcyjność'' i, co za tym idzie - na wybór strategii w
grze.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{dice.pdf}
  \end{center}
  \caption{Prawdopodobieństwa uzyskania poszczególnych wyników dla
    rzutu dwiema szcześciościennymi kośćmi do gry}
  \label{dice}
\end{figure}

\subsubsection{Karty rozwoju}
Kolejnym czynnikiem wprowadzającym w niewielkim stopniu losowość są
karty rozwoju. Za określoną ilość kart surowców gracz może nabyć kartę
rozwoju, ciągnąc ją z wierzchu potasowanego i zakrytego stosu. W grze
występuje pięć rodzajów kart:

\begin{itemize}
\item karta rycerza
\item karty postępu (,,monopol'', ,,budowa dróg'' i ,,wynalazek'')
\item karta ,,punkt zwycięstwa''
\end{itemize}

Karta rycerza stanowi element walki, element ten zostanie omówiony
później. Karty postępu w różny sposób przyspieszają rozwój
gracza. Ciekawym elementem jest jednak karta ,,punkt zwycięstwa'',
która stanowi istotny element zaskoczenia w grze. W związku z tym, że
po ,,zakupie'' karty rozwoju jest ona zakryta dla pozostałych graczy,
nie znają oni rodzaju karty dopóki ta nie zostanie zagrana. Karty
,,punkt zwycięstwa'' ujawniane są bezpośrednio przed końcem gry. W
rezultacie gracz posiadający np. trzy karty rozwoju, może potencjalnie
posiadać trzy dodatkowe punkty zwycięstwa, które umożliwią mu znacznie
szybsze zakończenie gry.

\subsubsection{Handel}
Podczas rozgrywki gracze mają możliwość wymiany posiadanych surowców z
innymi graczami lub z bankiem.

Handel z bankiem odbywa się po określonych ,,kursach
wymiany''. Początkowo niekorzystne kursy można zmieniać poprzez
budowanie portów (osad) przy szlakach handlowych. Pozwalają one nawet
na dwukrotne zwiększenie korzystności takich wymian.

Przy handlu z innymi uczestnikami nie ma żadnych narzuconych z góry
,,kursów wymiany'' (zależą one wyłącznie od graczy). Zawsze jednak
musi to być wymiana - zabronione jest pozbywanie się surowców.

\subsubsection{Walka}
Ostatnim istotnym elementem gry jest ,,walka''. Zagranie karty armii
oraz wyrzucenie siódemki daje możliwość przesunięcia pionka,
tzw. ,,rozbójnika''. Pole zajmowane przez ,,rozbójnika'' nie przynosi
graczom żadnego dochodu. Dodatkowo, po przesunięciu pionka, gracz ma
możliwość ,,obrabowania'' jednej z sąsiadujących z nim osad lub miast,
zabierając losowo wybraną kartę surowca od ich właściciela.

\subsubsection{Cel gry}
Celem gry jest zdobycie 10 punktów zwycięstwa, które są przyznawane
za:

\begin{itemize}
\item osadę - 1 punkt
\item miasto - 2 punkty
\item najdłuższą drogę - 2 punkty
\item największą armię - 2 punkty
\item kartę rozwoju ,,punkt zwycięstwa'' - 1 punkt
\end{itemize}

\clearpage

\section{Analiza istniejących rozwiązań}
W tym rozdziale przedstawionych zostało kilka powszechnie dostępnych,
działających rozwiązań. Wszystkie zaprezentowane implementacje gry
wymagają od użytkownika posiadania dodatkowego oprogramowania (poza
przeglądarką internetową). Większość z nich jest przystosowana do
jednej konkretnej platformy (np. PC z systemem Microsoft
Windows). Wadą tego typu rozwiązań jest to, że stworzenie wersji na
inną platformę (np. urządzenia mobilne) często wiąże się z
koniecznością stworzenia zupełnie nowej aplikacji.

\subsection{Pioneers}
Pierwotna nazwa tej aplikacji brzmiała \emph{gnocatan}. Aplikacja
została udostępniona w 2000 roku na licencji GNU GPL. Gra została
napisana całości w języku \emph{C}, podzielona jest na serwer i część
kliencką. Na stronie projektu \cite{pioneers} możemy znaleźć kod
źródłowy i wersje binarne, skompilowane na wszystkie popularne
platformy sprzętowe. Zrzut ekranu z gry \emph{Pioneers} został
przedstawiony na \imref{pioneers}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{pioneers.png}
  \end{center}
  \caption{Zrzut ekranu z gry Pioneers}
  \label{pioneers}
\end{figure}

\subsection{JSettlers}
Aplikacja napisana w całości w Javie, rozwijana od początku 2004 roku
\cite{jsettlers}, dostępna na licencji GNU GPL. Aplikacja
przystosowana do uruchamiania w przeglądarce internetowej z
zainstalowanym środowiskiem uruchomieniowym Javy (\emph{ang. Java Runtime
  Environment}). Na \imref{jsettlers} został przedstawiony zrzut
ekranu z gry \emph{JSettlers}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{jsettlers.png}
  \end{center}
  \caption{Zrzut ekranu z gry JSettlers}
  \label{jsettlers}
\end{figure}

\subsection{Solito Server, MSN Games, PlayCatan.com}
Wszystkie te rozwiązania są oprogramowaniem własnościowym, w przypadku
dwóch ostatnich tytułów, płatnym. \emph{Solito Server} napisany został
przy użyciu technologii \emph{Adobe Flash}, dlatego jest w pewnym
stopniu uniezależniony od platformy sprzętowej (można go używać na
wszystkich platformach, na których dostępny jest \emph{Adobe
  Flash}). Pozostałe tytuły to oprogramowanie działające wyłącznie pod
kontrolą systemu operacyjnego \emph{Microsoft Windows}, wymagające
dodatkowo instalacji.

\subsection{Catan - The First Island}
Jest to prawdopodobnie jedyna implementacja gry dedykowana urządzeniom
mobilnym. Pierwotnie aplikacja napisana została w Javie dla urządzeń
mobilnych, przez niemiecką firmę \emph{Exozet Games}. W połowie 2009
roku pojawiła się także wersja przeznaczona dla konsoli \emph{Nintendo
  DS}. Oba rozwiązania umożliwiają rozgrywkę z graczem komputerowym
(\emph{AI}) oraz z innymi graczami poprzez \emph{Bluetooth} lub
\emph{WiFi}. Nie posiadają one niestety żadnego centralnego
serwera. Obie opisywane wersje są płatnym oprogramowaniem
własnościowym.

\clearpage

\section{Określenie funkcji aplikacji i wybór technologii}
Projektowana aplikacja składać się będzie z dwóch części: serwera i
klienta. Aplikacja w założeniu będzie wymagać bardzo dużego nakładu
pracy, w tym zaprojektowania interfejsu graficznego i stworzenia
grafiki. Aby umożliwić rozwój aplikacji, zdecydowałem się udostępnić
całość kodu jako wolne oprogramowanie na zasadach Powszechnej Licencji
Publicznej GNU Affero w wersji 3\cite{affero}.

Do zaimplementowania części serwerowej aplikacji zostanie wykorzystany
język \emph{Ruby} i framework \emph{Ruby on Rails}. Wybór można
uzasadnić bardzo dobrym wsparciem frameworka dla architektury
\emph{REST}, która zostanie wykorzystana do stworzenia \emph{API}.

\subsection{Ruby}
Język \emph{Ruby} został stworzony w 1995 roku przez Yukihiro
Matsumoto. Za bazę do jego stworzenia posłużyły języki takie jak
\emph{Lisp}, \emph{Perl}, \emph{Python}, \emph{Smalltalk}, a także
\emph{CLU} i \emph{Eiffel}. Jest to wieloparadygmatowy, dynamicznie
typowany, interpretowany język programowania bardzo wysokiego poziomu
(ang. \emph{VHLL} \footnote{VHLL - very high-level programming language
  \cite{vhll} }) \cite{ruby}. Najważniejszymi cechami języka są:

\begin{itemize}
\item pełna obiektowość - nie ma podziału na typy proste (wbudowane) i
  złożone. Pełnoprawnymi obiektami są także klasy, metody, wyrażenia
  lambda, itp.
\item pseudoklasyczny mechanizm dziedziczenia jednobazowego
\item moduły oferujące mechanizm zastępujący dziedziczenie wielobazowe
  (ang. \emph{mixin} \cite{mixin})
\item otwarte klasy, pozwalające na zmianę w dowolnym momencie
  wykonywania programu właściwości zdefiniowanych już klas (włącznie z
  klasami pochodzącymi z biblioteki standardowej języka)
\item \emph{monkey patching} - wykorzystanie mechanizmu otwartych klas
  do zmiany działania już istniejącego kodu w czasie wykonywania
  programu \cite{monkeypatch}
\item metaprogramowanie - mechanizm ten umożliwia tworzenie kodu,
  który generuje kod w czasie wykonywania programu
  \cite{metaprogramming}
\item ,,kacze typowanie'' - typy obiektów przekazywanych jako
  argumenty funkcji nie są w żaden sposób sprawdzane. Dzięki temu nie
  jest konieczne tworzenie skomplikowanych hierarchii dziedziczenia
  klas, wystarczy jedynie zaimplementować w klasach pewien wspólny
  podzbiór właściwości wymaganych przez wywoływaną na nich funkcję
  \cite{ducktyping}
\item domknięcia - mechanizm wiązania tworzonych funkcji z ich
  otoczeniem. Podczas wywołania funkcji ma ona dostęp do zmiennych,
  które zostały dowiązane do niej podczas jej tworzenia (nawet jeśli
  są one niedostępne podczas jej wywołania) \cite{closures}
\item przejrzysta, czytelna składnia
\item bogata biblioteka standardowa
\end{itemize}

Język \emph{Ruby} doczekał się wielu różnych implementacji, z których
najbardziej dojrzałe są:

\begin{itemize}
\item \emph{Matz's Ruby Interpreter} (\emph{MRI}) - intepreter
  stworzony w języku \emph{C}, uznawany \emph{de facto} za
  implementację referencyjną\cite{mri}
\item \emph{JRuby} - interpreter stworzony w języku Java,
  uruchamiany w \emph{wirtualnej maszynie Javy}\cite{jruby}
\end{itemize}

Głównym wskaźnikiem świadczącym o dojrzałości interpretera jest
możliwość uruchomienia na nim frameworka \emph{Ruby on
  Rails}. Wymienione wyżej implementacje najczęściej wykorzystywane są
do budowy środowisk produkcyjnych. Pozostałe implementacje są w
większości w fazie rozwoju, zaliczają się do nich
m.in. \emph{Cardinal}, \emph{IronRuby}, \emph{MacRuby}, \emph{MagLev},
\emph{Rubinius}, \emph{Ruby.NET} oraz \emph{XRuby}.

Ogromną zaletą języka \emph{Ruby} jest fakt, iż wszystkie wyżej
wymienione implementacje, za wyjątkiem \emph{MagLev}, to wolne
oprogramowanie. Rozwojem języka kieruje społeczność, tworząca kod
\emph{MRI}, nie jest on uzależniony od żadnych zewnętrznych firm (jak
ma to miejsce w przypadku języka \emph{Java} i firmy \emph{Sun
  Microsystems}).

W związku z tym, że język \emph{Ruby} utożsamiany jest głównie z
technologiami webowymi, należałoby nadmienić fakt, iż tworzenie
aplikacji internetowych nie miało wpływu na rozwój tego języka (tak
jak ma to miejsce w przypadku języka \emph{PHP}). Zamierzeniem
Yukihiro Matsumoto było stworzenie języka, który byłby
,,skuteczniejszy niż \emph{Perl} oraz bardziej zorientowany obiektowo
niż \emph{Python}''\cite{matzinterview}. Język \emph{Ruby} posiada
bardzo bogatą bibliotekę standardową, a także dużą ilość bibliotek
zewnętrznych (tzw. \emph{gemów}). Równie dobrze nadaje się do
tworzenia aplikacji okienkowych, serwerów sieciowych, jak i skryptów
systemowych. Nie zmienia to jednak faktu, że popularność języka wiąże
się nierozłącznie z frameworkiem \emph{Ruby on Rails}.

\subsection{Ruby on Rails}
Twórcą frameworka \emph{Ruby on Rails} jest duński programista David
Heinemeier Hansson. Framework powstał w wyniku prac nad aplikacją
\emph{Basecamp}, został udostępniony w połowie 2004 roku. Wzrost
popularności \emph{Ruby on Rails} nastąpił po ogłoszeniu przez firmę
\emph{Apple Inc.}, że będzie on dostarczany wraz z systemem \emph{Mac
  OS X v10.5 ''Leopard''}\cite{rubyonrails}. Swoje ogromne możliwości
framework zawdzięcza wykorzystaniu takich cech języka, jak
metaprogramowanie, kacze typowanie, czy możliwość otwierania klas.

Framework \emph{Ruby on Rails} umożliwia tworzenie aplikacji
internetowych w oparciu o wzorzec \emph{MVC}\footnote{MVC -
  model-widok-kontroler (ang. Model-View-Controller), wzorzec
  projektowy, którego założeniem jest podział aplikacji na modele,
  widoki i kontrolery. Podział jest realizowany w taki sposób, aby
  modyfikacja jednego elementu miała jak najmniejszy wpływ na
  działanie pozostałych\cite{mvc}}. \emph{Ruby on Rails} obsługuje
wszystkie popularne silniki bazodanowe poprzez bibliotekę mapowania
obiektowo-relacyjnego \emph{ActiveRecord} \cite{orm}. Aplikacje
napisane przy użyciu frameworka mogą być uruchamiane na serwerach
webowych, takich jak \emph{Apache}, \emph{Lighttpd}, \emph{Abyss},
\emph{Thin}, \emph{Mongrel}. W przypadku zastosowania \emph{JRuby},
mogą być to m.in. serwery aplikacji \emph{JBoss}, \emph{GlassFish} lub
\emph{Apache Geronimo}.

Cały framework jest udostępniony na zasadach licencji \emph{MIT}
\cite{mit}.

\subsubsection{Architektura Ruby on Rails}
Framework \emph{Ruby on Rails} składa się z komponentów, z których
główne to:

\begin{itemize}
\item \emph{ActiveRecord} - biblioteka mapowania
  obiektowo-relacyjnego, stworzona na podstawie wzorca projektowego o
  tej samej nazwie\cite{activerecord}. Biblioteka ta oferuje znacznie
  więcej, niż wynika z implementowanego wzorca, m.in. różne rodzaje
  asocjacji (w tym asocjacje polimorficzne\cite{polymorphic}),
  mechanizm dziedziczenia jednotabelowego (\emph{STI}\footnote{STI -
    dziedziczenie jednotabelowe (ang. Single Table Inheritance) -
    technika umożliwiająca odzwierciedlenie w jednej tabeli relacyjnej
    bazy danych obiektów wielu dziedziczących po sobie
    klas\cite{sti}}) oraz walidatory
\item \emph{ActionPack} - biblioteka umożliwiająca tworzenie
  kontrolerów i widoków, odpowiada również za kierowanie zapytań do
  odpowiednich akcji kontrolerów (tzw. \emph{routing})
\item \emph{ActiveSupport} - biblioteka dodająca wiele użytecznych
  funkcji do klas biblioteki standardowej, ułatwiających tworzenie
  aplikacji webowych (i nie tylko)
\item \emph{ActionMailer} - biblioteka służąca do wysyłania wiadomości
  e-mail, np. poprzez zewnętrzne serwery \emph{SMTP}
\item \emph{ActiveResource} - biblioteka umożliwiająca mapowanie
  zasobów \emph{REST}\footnote{REST - ang. Representational State
    Transfer, styl architektury zakładający traktowanie informacji
    udostępnianych przez aplikacje webowe jako zasoby, na których
    wywoływane są działania takie jak: tworzenie zasobu, odczyt,
    aktualizacja i usuwanie (ang. create, read, update,
    delete)\cite{rest}} na modele w aplikacji
\end{itemize}

Uproszczony diagram przedstawiający interakcje pomiędzy poszczególnymi
elementami frameworka został przedstawiony na
\imref{railsarchitecture}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{railsarchitecture.png}
  \end{center}
  \caption{Architektura Ruby on Rails}
  \label{railsarchitecture}
\end{figure}

\subsubsection{Rozwój Ruby on Rails}
Na początku roku 2008 światło dzienne ujrzał nowy framework do
tworzenia aplikacji webowych o nazwie \emph{Merb}, silnie inspirowany
przez \emph{Ruby on Rails}. Został on stworzony z inicjatywy Ezry
Zygmuntowicza, założyciela firmy \emph{Engine Yard}. W założeniach
oprogramowanie miało być szybsze i bardziej modularne niż jego
pierwowzór. Spory pomiędzy zwolennikami nowopowstałego frameworka a
dotychczasową społecznością spowodowały powstanie w niej pewnego
rodzaju rozłamu. Przy narastającej fali krytyki z obu stron, niedługo
po wydaniu \emph{Merba 1.0}, David Heinemeier Hansson ogłosił
połączenie obu grup programistów\cite{merge}. Utworzony zespół miał
się zająć połączeniem powstającego \emph{Merba 2} i \emph{Ruby on
  Rails 3}. Zgodnie z ustaleniami, pierwsze wydania \emph{Ruby on
  Rails 3} mają się pojawić pod koniec 2009 roku.

\subsection{JavaScript}
Język \emph{JavaScript} powstał pod koniec 1995 roku w firmie
\emph{Netscape Communications Corporation} jako alternatywa dla
uruchamianych w przeglądarce apletów \emph{Javy}. Jego twórcą jest
amerykański programista Brendan Eich. Począwszy od 1996 roku, język
jest standaryzowany przez \emph{ECMA International}\footnote{ECMA -
  Europejskie Stowarzyszenie na rzecz Standaryzacji Systemów
  Informacyjnych i Komunikacyjnych (ang. European association for
  standardizing information and communication systems), organizacja
  zajmująca się standaryzacją systemów informatycznych w
  Europie\cite{ecma}} jako \emph{ECMAScript}.
\label{javascript}

Pomimo swojej nazwy jasno kojarzącej się z językiem \emph{Java}, język
\emph{JavaScript} jest (z wyjątkiem kilku elementów) językiem
diametralnie od \emph{Javy} różnym. Największy wpływ na jego rozwój
miały języki takie jak: \emph{Self}, \emph{C}, \emph{Scheme},
\emph{Perl} oraz \emph{Python}\cite{javascript}. Aby upodobnić język
do błyskawicznie zyskującej wówczas popularność \emph{Javy},
zapożyczony został zestaw słów kluczowych i składnia. Ta prosta
marketingowa sztuczka zaowocowała całkowitym niezrozumieniem tego
języka przez programistów, którzy przez wiele lat traktowali go jako
pewien podzbiór języka \emph{Java}. W rzeczywistości, język
\emph{JavaScript} jest znacznie bliżej spokrewniony z językami
funkcyjnymi, takimi jak \emph{Lisp}.

Interpreter \emph{JavaScriptu} wbudowany jest w niemal każdą
współczesną przeglądarkę internetową, co czyni go jednym z najbardziej
rozpowszechnionych języków programowania na świecie.

Najważniejszymi cechami języka, odróżniającymi go od języków
,,c-pochodnych'' (w tym od \emph{Javy}) są:

\begin{itemize}
\item dynamiczne typowanie
\item domknięcia
\item prawie całkowita obiektowość - występuje podział na typy proste
  i obiekty. Obiekty są tablicami asocjacyjnymi, ich właściwości można
  dowolnie modyfikować podczas wykonania programu (w praktyce
  mechanizm ten jest bardzo podobny do ,,otwierania klas'' w języku
  \emph{Ruby}).
\item dziedziczenie prototypowe - mechanizm dziedziczenia
  bezklasowego. Jedyną cechą umożliwiającą stwierdzenie pokrewieństwa
  obiektów jest posiadanie przez nie wspólnego prototypu
\end{itemize}

Główne implementacje \emph{JavaScriptu} to\cite{javascript}:

\begin{itemize}
\item \emph{SpiderMonkey} - pierwszy interpreter, napisany przez
  twórcę języka w \emph{C}, wykorzystywany m.in. w przeglądarce \emph{Mozilla
    Firefox}.
\item \emph{Rhino} - interpreter napisany w \emph{Javie}, pozwala na
  uruchamianie \emph{JavaScriptu} na wirtualnej maszynie \emph{Javy}
\item \emph{KDE's JavaScript engine} - wykorzystywany w przeglądarce
  \emph{Konqueror}
\item \emph{WebKit} - napisany w \emph{C++} interpreter używany
  m.in. w przeglądarce \emph{Safari} firmy \emph{Apple Inc.}
\item \emph{V8} - zaimplementowany w \emph{C++} interpreter używany w
  przeglądarce \emph{Google Chrome}
\end{itemize}

Rozmaite dialekty \emph{JavaScriptu} (a dokładniej standardu
\emph{ECMAScript}) znalazły się także poza przeglądarkami
internetowymi. Wśród nich wyróżnić można m.in.:

\begin{itemize}
\item \emph{JScript} - dialekt stworzony i rozwijany przez firmę
  \emph{Microsoft}. Oprócz wbudowania w przeglądarkę \emph{Microsoft
    Internet Explorer} interpreter tego dialektu jest również częścią
  środowiska \emph{Microsoft Windows Scripting Host}, jest to także
  jeden z podstawowych języków środowiska \emph{.NET}
\item \emph{ActionScript} - dialekt rozwijany przez firmę \emph{Adobe
    Systems}, wykorzystywany w środowisku \emph{Adobe Flash}
\end{itemize}

\subsubsection{XMLHttpRequest (Ajax)}
Po rozpowszechnieniu się \emph{JavaScriptu} w przeglądarkach
internetowych, był on używany głównie do ,,upiększania'' stron
\emph{HTML} i dodawania do nich dynamicznych elementów. Stał się swego
rodzaju dodatkiem, ułatwiającym korzystanie ze stron.

Sytuacja zaczęła się zmieniać po wprowadzeniu przez firmę
\emph{Microsoft} obiektu \emph{ActiveX} nazwanego \emph{XMLHTTP} w
przeglądarce \emph{Microsoft Internet Explorer 5}. Najważniejszą cechą
tego mechanizmu była możliwość komunikacji z serwerem bez konieczności
przeładowywania całego dokumentu. W krótkim czasie podobne rozwiązania
zostały zaimplementowane w konkurencyjnych przeglądarkach, m.in.w
\emph{Mozilli} i \emph{Safari}. Pomimo tego, że funkcje te były
dostępne w przeglądarkach od końca 1999 roku, pierwsze duże aplikacje
zaczęły z nich korzystać dopiero w 2004 roku. Najważniejszymi
aplikacjami, które spopularyzowały opisywany mechanizm były
\emph{Gmail} i \emph{Google Maps}, stworzone przez firmę \emph{Google
  Inc.} W 2005 roku wprowadzony został termin \emph{Ajax}
(ang. asynchronous JavaScript and XML), oznaczający wykorzystanie
języków \emph{JavaScript} i \emph{XML} do asynchronicznej komunikacji
z serwerem\footnote{w rzeczywistości jednak, żaden z wymienionych
  elementów nie jest wymagany. W niektórych przeglądarkach zamiast
  \emph{JavaScriptu} można użyć innego języka (np. \emph{VBScript}),
  zamiast \emph{XML}-a często jest używany \emph{JSON} lub zwykły
  tekst, a zapytania wcale nie muszą być asynchroniczne\cite{ajax}}.

W związku z ograniczeniami narzucanymi przez przeglądarki internetowe,
wszystkie zapytania wykonywane przy pomocy skryptów muszą odwoływać
się do domeny, z której pobrany został dokument \emph{HTML} (ang. same
origin policy\cite{origin}). Dla aplikacji wymagających komunikacji z
różnymi domenami (np. ściągającymi dane z innych aplikacji) powstało
rozwiązanie nazwane \emph{JSONP}. W uproszczeniu polega ono na
dodawaniu do kodu dokumentu \emph{HTML} tagu \texttt{<script>}. Tag
ten może zostać dodany z wnętrza działającego w przeglądarce skryptu,
spowoduje on załadowanie i zinterpretowanie przez przeglądarkę kodu
pochodzącego z dowolnej domeny\cite{json}. Rozwiązanie to jest używane
do przesyłania danych w formacie \emph{JSON}. Przesyłany obiekt musi
być otoczony wywołaniem funkcji zwrotnej (ang. callback), w celu
poinformowania skryptu o otrzymaniu danych. Podobne rozwiązanie jest
używane również do tzw. leniwego ładowania kodu aplikacji (dynamiczne
ładowanie zależności). Należy zaznaczyć, że ładowanie kodu z innych
domen jest potencjalnie niebezpiecznym działaniem i powinno być
wykorzystywane z dużą rozwagą.

\subsubsection{HTTP Push (Comet)}
W przypadku standardowego wykorzystania technologii \emph{Ajax},
przesyłanie danych odbywa się na żądanie przeglądarki internetowej. W
niektórych rozwiązaniach taki mechanizm jest zbyt mało wydajny i
wprowadza w komunikacji niepożądane opóźnienia. Najprostszym
przykładem takiej aplikacji jest czat. W klasycznym rozwiązaniu każdy
klient musi co pewien czas odpytywać serwer o to, czy pojawiły się na
nim jakieś nowe wiadomości. Im mniejszy jest czas pomiędzy
poszczególnymi zapytaniami, tym większa jest ilość wykonywanych
zapytań i co za tym idzie, tym większe jest obciążenie
serwera. Technika ta jest także nazywana \emph{HTTP
  Pull}\footnote{ang. pull technology, client pull - styl komunikacji
  sieciowej, w którym wszystkie połączenia są inicjowane przez
  klienta\cite{pull}}, schemat jej działania został przedstawiony na
\imref{pull}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{pull.pdf}
  \end{center}
  \caption{Schemat działania mechanizmu odpytywania (\emph{HTTP
      Pull})}
  \label{pull}
\end{figure}

Jeśli przyjrzeć się bliżej aplikacji takiej jak \emph{Gmail}, okazuje
się, że nie wykonuje ona cyklicznego odpytywania serwera, a wszystkie
dane przesyłane są do klienta niemalże bez opóźnień. Najprostszym
sposobem na uniknięcie częstego odpytywania serwera jest zastosowanie
mechanizmu wydłużonego odpytywania (ang. long polling). Polega on na
wydłużaniu czasu trwania zapytań poprzez opóźnianie reakcji
serwera. Jeśli po otrzymaniu zapytania na serwerze nie ma żadnych
danych do pobrania, zamiast wysyłać informację o braku danych serwer
wstrzymuje się z odpowiedzią do czasu ich nadejścia. W przypadku, gdy
na serwerze pojawią się dane, są one natychmiast wysyłane do klienta
poprzez otwarte połączenie. W przypadku, gdy zostanie przekroczony
maksymalny czas trwania połączenia (ang. timeout) jest ono zamykane. W
obu przypadkach klient natychmiastowo wywołuje kolejne zapytanie,
które ponownie oczekuje na pojawienie się danych. Schemat działania
takiego mechanizmu został przedstawiony na \imref{longpolling}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{longpolling.pdf}
  \end{center}
  \caption{Schemat działania mechanizmu wydłużonego odpytywania}
  \label{longpolling}
\end{figure}

Niewątpliwą wadą przedstawionego rozwiązania jest fakt, iż w
przypadku, gdy dane pojawiają się na serwerze z dużą częstotliwością,
wywoływanych jest dużo pojedynczych zapytań. Skutkuje to oczywiście
wzrostem obciążenia serwera. W mechanizmie wydłużonego odpytywania
wykorzystywane są asynchroniczne zapytania \emph{XMLHttpRequest}. W
przypadku pobierania danych z innych domen wykorzystywany jest
mechanizm \emph{JSONP}.

Innym, bardziej wyrafinowanym sposobem komunikacji poprzez \emph{HTTP
  Push} jest strumieniowanie danych. Do strumieniowania danych
wykorzystywany jest fakt, iż wszystkie współczesne przeglądarki
internetowe renderują strony progresywnie. W związku z tym, możliwe
staje się stworzenie ,,nieskończonego'' zapytania, które będzie
interpretowane przez silnik na bieżąco, w chwili pojawiania się nowych
elementów. Do stworzenia takiego zapytania wykorzystywany jest ukryty
znacznik \texttt{<iframe>}. Znacznik ten umożliwia zagnieżdżenie w
dokumencie innego dokumentu, pochodzącego z innego adresu
internetowego\footnote{w tym przypadku również nie jest możliwe
  załadowanie dokumentu z innej domeny, zgodnie z polityką
  bezpieczeństwa przeglądarek}. Podobnie jak w przypadku \emph{JSONP}
przesyłane dane muszą być otoczone wywołaniem funkcji, która ma je
odebrać. Dodatkowo całość musi zostać otoczona znacznikiem
\texttt{<script>}. Każdy taki znacznik jest renderowany
(interpretowany) przez przeglądarkę zaraz po jego otrzymaniu. W
przypadku, gdy na serwerze nie ma żadnych danych, wysyłany jest co
pewien czas pusty znacznik, w celu utrzymania połączenia. Schemat
działania mechanizmu strumieniowania został przedstawiony na
\imref{streaming}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{streaming.pdf}
  \end{center}
  \caption{Schemat mechanizmu strumieniowania danych}
  \label{streaming}
\end{figure}

W związku z tym, że opisywane mechanizmy wykorzystują techniki
nieobjęte żadną specyfikacją, ich działanie jest w dużej mierze
zależne od implementacji poszczególnych przeglądarek
internetowych. Największym wyzwaniem jest przystosowanie wymienionych
technik do przeglądarek w urządzeniach mobilnych. Okazuje się również,
że użycie \emph{HTTP Push} na powszechnie używanych serwerach
\emph{HTTP} jest wysoce nieefektywne lub wręcz niemożliwe. Niemal
wszystkie dostępne rozwiązania wymagają uruchomienia dodatkowych
serwerów, odpowiedzialnych wyłącznie za obsługę \emph{HTTP Push}. Są
to serwery takie jak: \emph{Caplin Liberator}, \emph{Cometd},
\emph{ErlyComet}, \emph{GlassFish}, \emph{Jetty},
\emph{Lightstreamer}, \emph{Meteor}, \emph{Orbited}, \emph{Persevere}
i \emph{RMDS2Web Server}\cite{cometmaturity}. Dodatkową przeszkodą w
komunikacji przeglądarki z dodatkowym serwerem jest opisywane już
wcześniej zabezpieczenie \emph{same origin policy}. Całość komplikuje
również fakt, że przeglądarki internetowe realizują te zabezpieczenia
w różny sposób\cite{xssinfo}.

Wszystkie opisywane w tym rozdziale techniki noszą wspólną nazwę
\emph{Comet}\cite{comet}. W 2007 roku organizacja \emph{DOJO
  Foundation}\footnote{DOJO Foundation - niedochodowa
  (ang. non-profit) organizacja zajmująca się promocją biblioteki
  \emph{Dojo Toolkit}\cite{dojo}} podjęła się również próby
ustandaryzowania tych rozwiązań pod nazwą \emph{protokołu
  Bayeux}\cite{bayeux}. Alternatywą dla \emph{Cometa} jest stosowanie
rozwiązań pochodzących z apletów \emph{Javy} lub aplikacji \emph{Adobe
  Flash}, które mogą samodzielnie nawiązywać połączenia \emph{TCP}
(bez udziału przeglądarki internetowej). Powstająca specyfikacja
języka \emph{HTML 5} zawiera również rozwiązanie nazwane \emph{Web
  Sockets API}, które umożliwia dwustronną komunikację z serwerem
\emph{HTTP}\cite{websockets}.

\subsubsection{DOM}
Obiektowy model dokumentu(ang. Document Object Model) jest konwencją
reprezentacji dokumentów \emph{XML}, \emph{XHTML} i \emph{XML} w
postaci modelu obiektowego. Jest on wymagany przez język
\emph{JavaScript} do odczytywania i modyfikowania struktury dokumentu
z poziomu kodu\cite{dom}. Jest to zdecydowanie najbardziej niespójny
element współczesnych przeglądarek. Ma to związek m.in. z tym, że
pierwsze próby ustandaryzowania tego rozwiązania odbyły się w 1997
roku, a standard wszedł w powszechne użycie dopiero około roku
2000. Niespójności te są na tyle duże, że pisząc nawet prosty skrypt
odwołujący się bezpośrednio do \emph{DOM-u} przeglądarki, możemy
spodziewać się, że nie będzie on przenośny. Dostosowywanie kodu do
różnic występujących w poszczególnych przeglądarkach jest wyjątkowo
żmudnym i czasochłonnym zadaniem. W praktyce okazuje się, że pisanie
kodu operującego bezpośrednio na dokumencie jest zjawiskiem stosunkowo
rzadkim. W większości przypadków wykorzystuje się do tego celu gotowe
biblioteki, zapewniające pewien poziom abstrakcji w dostępie do
\emph{DOM-u}, przenośność kodu pomiędzy różnymi przeglądarkami oraz
poprawiające użyteczność samego
\emph{JavaScriptu}. Najpopularniejszymi bibliotekami tego typu są:
\emph{jQuery}, \emph{Prototype}, \emph{DOJO Toolkit}, \emph{Yahoo!
  User Interface Library} oraz \emph{Google Web Toolkit}.

\clearpage

\section{Projektowanie aplikacji}

\subsection{Plansza}\label{sec:board}
Jednym z podstawowych problemów, jakie należy rozwiązać projektując
aplikację, jest przechowywanie planszy w relacyjnej bazie
danych. Naturalnie, pierwszym pomysłem było wykorzystanie mechanizmu z
działającego rozwiązania, a mianowicie z gry \emph{Pioneers}.

Plansza do gry w ,,Osadników'' składa się w pierwotnej wersji z 37
połączonych ze sobą sześciokątów. Niektóre ich wierzchołki i krawędzie
przeznaczone są pod budowę dróg i osad. Sytuację najbardziej
komplikuje fakt, iż większość wierzchołków i krawędzi jest wspólna dla
kilku połączonych sześciokątów. Rozwiązanie zastosowane w grze
\emph{Pioneers} polega na ułożeniu wszystkich sześciokątów na planszy
w dwuwymiarowej tablicy. Dodatkowo każdy z nich posiada dwie
sześcioelementowe tablice wskaźników, wskazujących na odpowiednie
wierzchołki i krawędzie. Przy tworzeniu wierzchołka lub krawędzi
ustawiane są odpowiednie wskaźniki w sąsiadujących sześciokątach. To
stosunkowo proste rozwiązanie okazuje się być trudne w realizacji w
relacyjnej bazie danych. Przykładowe połączenie sześciokąta z
wierzchołkami wymagałoby użycia sześciu kluczy obcych lub utworzenia
dodatkowej tabeli łączącej. Rozwiązanie takie wprowadza do bazy dużo
niepotrzebnych połączeń i jest mało wydajne.

Jednym z działań, które gracz może wykonać podczas gry, jest
zbudowanie przez niego osady. Do sprawdzenia poprawności współrzędnych
budowanej osady niezbędnych jest wykonanie kilku czynności:

\begin{itemize}
\item sprawdzenie, czy na jednym z sąsiadujących wierzchołków nie
  znajduje się już inna osada - minimalna odległość pomiędzy osadami
  wynosi dwie drogi (dwie krawędzie)
\item sprawdzenie, czy na jednej z sąsiadujących krawędzi wybudowana
  jest droga należąca do gracza - budowane osady muszą być połączone
  drogami
\item sprawdzenie, czy jeden z sąsiadujących sześciokątów jest
  lądem. Osady nie mogą być budowane na brzegach planszy (na
  ,,morzu'')
\end{itemize}

Bardzo podobne czynności musimy wykonać, aby stwierdzić poprawność
współrzędnych budowanej przez gracza drogi. Okazuje się więc, że
najczęściej wykonywaną operacją jest pobranie sąsiadujących
(dołączonych) elementów planszy. Najlepiej więc, gdyby na podstawie
współrzędnych budowanej osady można było łatwo wyliczyć zbiór
współrzędnych dołączonych do wierzchołka sześciokątów, wierzchołków i
krawędzi. Aby ułatwić przekształcenia, wszystkie elementy planszy
muszą być jednoznacznie identyfikowalne na podstawie dwóch
współrzędnych.

Oprócz zbioru sześciokątów, wierzchołków i krawędzi, plansza do gry
powinna zawierać informacje o jej rozmiarze (ilości wierszy i kolumn)
oraz o aktualnym położeniu ,,rozbójnika''.

\subsubsection{Sześciokąty}
Podobnie jak w implementacji gry \emph{Pioneers}, sześciokąty zostały
ułożone w dwuwymiarową tablicę. Każdy z nich ma przypisaną pozycję,
składającą się z numeru wiersza $x$ i kolumny $y$. Sposób numeracji
sześciokątów został przedstawiony na \imref{board}. Dodatkowo, każdy
sześciokąt powinien zawierać następujące informacje:

\begin{itemize}
\item typ - sześciokąt może reprezentować wzgórze, pole uprawne, las,
  pastwisko, górę, pustynię lub morze
\item wynik rzutu kością, po wyrzuceniu którego pole przynosi
  dochód; sześciokąty reprezentujące morze i pustynię nie posiadają
  żadnej wartości
\item pozycję (kierunek) i rodzaj szlaku handlowego - cecha ta dotyczy
  wyłącznie niektórych sześciokątów reprezentujących morze
\end{itemize}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{board.pdf}
  \end{center}
  \caption{Zasada numerowania sześciokątów na planszy}
  \label{board}
\end{figure}

\subsubsection{Wierzchołki}
Numerowanie wierzchołków jest nieco bardziej skomplikowanym
zadaniem. Wykorzystany został tutaj fakt, iż, przy numeracji
sześciokątów przedstawionej na \imref{board}, w każdym z nich można
wyróżnić wierzchołki ,,górne'' (posiadające numer wiersza taki jak
numer wiersza sześciokąta) i ,,dolne'' (posiadające numer wiersza o
jeden większy niż numer wiersza sześciokąta). Dla ujednolicenia
schematu numeracji, konieczne stało się ponumerowanie dodatkowych
pozycji, w których nie występują wierzchołki. Omawiany sposób
numeracji został przedstawiony na \imref{nodes}. Dla planszy o
rozmiarach $x$ wierszy i $y$ kolumn, otrzymujemy tablicę wierzchołków
posiadającą wysokość $x+1$ wierszy i szerokość $2y+2$ kolumn. Każdy
zasiedlony wierzchołek musi należeć do któregoś z graczy oraz posiadać
dodatkową informację o tym, czy jest osadą, czy miastem.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{nodes.pdf}
  \end{center}
  \caption{Zasada numerowania wierzchołków na planszy}
  \label{nodes}
\end{figure}

\subsubsection{Krawędzie}
Krawędzie numerowane są na podobnej zasadzie co wierzchołki. Również
niezbędne okazało się wprowadzenie niepowiązanych z sześciokątami
pozycji. Sposób numeracji krawędzi został przedstawiony na
\imref{edges}. Plansza o rozmiarach $x$ wierszy i $y$ kolumn, posiada
tablicę krawędzi o wysokości $x+1$ wierszy i szerokości $3y+4$
kolumn. Podobnie jak w przypadku wierzchołka -- zasiedlona krawędź
musi należeć do jednego z graczy.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{edges.pdf}
  \end{center}
  \caption{Zasada numerowania krawędzi na planszy}
  \label{edges}
\end{figure}

\subsubsection{Obliczanie pozycji elementów dołączonych}
\label{sec:calculations}
Po wprowadzeniu przedstawionych schematów numeracji, możliwe staje się
wyznaczenie pozycji elementów sąsiadujących z ponumerowanymi
sześciokątami, wierzchołkami i krawędziami. Zbiory dołączonych
sześciokątów $\text{hexes}_{adj}$, wierzchołków $\text{nodes}_{adj}$ i
krawędzi $\text{edges}_{adj}$ do danego sześciokąta o współrzędnych
$(x, y)$ zostały przedstawione kolejno w równaniach \ref{hexhexes},
\ref{hexnodes} i \ref{hexedges}. Każdy sześciokąt posiada po sześć
sąsiadujących pozycji elementów każdego typu.

\begin{equation}
  \begin{aligned}
    \text{hexes}_{adj}(\text{hex}_{x,y})=
    \{
    (x-1, y+1),
    (x-1, y),
    (x, y-1),\\
    (x+1, y-1),
    (x+1, y),
    (x, y+1)
    \}
  \end{aligned}
  \label{hexhexes}
\end{equation}
\begin{equation}
  \begin{aligned}
    \text{nodes}_{adj}(hex_{x,y})=\{
    (x+1, 2y),
    (x+1, 2y+1),
    (x+1, 2y+2),\\
    (x, 2y+3),
    (x, 2y+2),
    (x, 2y+1)
    \}
  \end{aligned}
  \label{hexnodes}
\end{equation}
\begin{equation}
  \begin{aligned}
    \text{edges}_{adj}(hex_{x,y})=\{
    (x+1, 3y+2),
    (x+1, 3y+4),
    (x, 3y+6),\\
    (x, 3y+5),
    (x, 3y+4),
    (x, 3y+3)
    \}
  \end{aligned}
  \label{hexedges}
\end{equation} \\

W przypadku wyznaczania elementów sąsiadujących z wierzchołkiem
sytuacja jest nieco bardziej skomplikowana. Zbiory elementów
dołączonych do danego wierzchołka są różne dla wierzchołków
znajdujących się w kolumnach parzystych i nieparzystych. Każdy ze
zbiorów składa się z trzech elementów. Zbiór sąsiadujących:
sześciokątów $\text{hexes}_{adj}$, wierzchołków $\text{nodes}_{adj}$ i
krawędzi $\text{edges}_{adj}$, z danym wierzchołkiem o współrzędnych
$(x, y)$, zostały przedstawione w równaniach \ref{nodehexes},
\ref{nodenodes} i \ref{nodeedges}.

\begin{equation}
  \text{hexes}_{adj}(\text{node}_{x,y})=
  \left\{
    \begin{array}{l r l}
      \begin{aligned}
      \{
      (x-1, \left\lfloor\frac{y}{2}\right\rfloor-1), \\
      (x-1, \left\lfloor\frac{y}{2}\right\rfloor), \\
      (x, \left\lfloor\frac{y}{2}\right\rfloor-1)
      \}
      \end{aligned} & \mbox{dla } y=2n, & n\in\mathbb{Z} \\[40pt]
      \begin{aligned}
        \{
        (x-1, \left\lfloor\frac{y}{2}\right\rfloor), \\
        (x, \left\lfloor\frac{y}{2}\right\rfloor-1), \\
        (x, \left\lfloor\frac{y}{2}\right\rfloor)
        \}
      \end{aligned} & y=2n+1, & n\in\mathbb{Z} \\
    \end{array} \right.
  \label{nodehexes}
\end{equation}
\begin{equation}
  \text{nodes}_{adj}(\text{node}_{x,y})=
  \left\{
    \begin{array}{l r l}
      \begin{aligned}
        \{
        (x-1, 3\left\lfloor\frac{y}{2}\right\rfloor+3), \\
        (x, 3\left\lfloor\frac{y}{2}\right\rfloor+3), \\
        (x, 3\left\lfloor\frac{y}{2}\right\rfloor+2)
        \}
      \end{aligned} & \mbox{dla } y=2n, & n\in\mathbb{Z} \\[40pt]
      \begin{aligned}
        \{
        (x, y+1), \\
        (x, y-1), \\
        (x+1, y-1)
        \}
      \end{aligned} & y=2n+1, & n\in\mathbb{Z} \\
    \end{array} \right.
  \label{nodenodes}
\end{equation}
\begin{equation}
  \text{edges}_{adj}(\text{node}_{x,y})=
  \left\{
    \begin{array}{l r l}
      \begin{aligned}
      \{
      (x-1, 3\left\lfloor\frac{y}{2}\right\rfloor+3), \\
      (x, 3\left\lfloor\frac{y}{2}\right\rfloor+3), \\
      (x, 3\left\lfloor\frac{y}{2}\right\rfloor+2)
      \}
      \end{aligned} & \mbox{dla } y=2n, & n\in\mathbb{Z} \\[40pt]
      \begin{aligned}
      \{
      (x, 3\left\lfloor\frac{y}{2}\right\rfloor+4), \\
      (x, 3\left\lfloor\frac{y}{2}\right\rfloor+2), \\
      (x, 3\left\lfloor\frac{y}{2}\right\rfloor+3)
      \}
      \end{aligned} & y=2n+1, & n\in\mathbb{Z} \\
    \end{array} \right.
  \label{nodeedges}
\end{equation} \\

Podobna sytuacja ma miejsce w przypadku wyliczania współrzędnych
elementów dołączonych do krawędzi. W tym przypadku dla trzech
następujących po sobie kolumn otrzymujemy trzy różne zbiory. Zbiory te
w przypadku dołączonych sześciokątów i wierzchołków składają się z
dwóch elementów, natomiast w przypadku krawędzi -- z czterech. Zbiory
sześciokątów $\text{hexes}_{adj}$, wierzchołków $\text{nodes}_{adj}$ i
krawędzi $\text{edges}_{adj}$, dla krawędzi o współrzędnych $(x,y)$,
zostały przedstawione w równaniach \ref{edgehexes}, \ref{edgenodes} i
\ref{edgeedges}.

\begin{equation}
  \text{hexes}_{adj}(\text{edge}_{x,y})=
  \left\{
    \begin{array}{l r l}
      \begin{aligned}
        \{
        (x, \left\lfloor\frac{y}{3}\right\rfloor-2), \\
        (x, \left\lfloor\frac{y}{3}\right\rfloor-1)
        \}
      \end{aligned} & \mbox{dla } y=3n, & n\in\mathbb{Z} \\[30pt]
      \begin{aligned}
        \{
        (x-1, \left\lfloor\frac{y}{3}\right\rfloor-1), \\
        (x, \left\lfloor\frac{y}{3}\right\rfloor-1)
        \}
      \end{aligned} & y=3n+1, & n\in\mathbb{Z} \\[30pt]
      \begin{aligned}
      \{
      (x-1, \left\lfloor\frac{y}{3}\right\rfloor), \\
      (x, \left\lfloor\frac{y}{3}\right\rfloor-1)
      \}
      \end{aligned} & y=3n+2, & n\in\mathbb{Z} \\
    \end{array} \right.
  \label{edgehexes}
\end{equation}
\begin{equation}
  \text{nodes}_{adj}(\text{edge}_{x,y})=
  \left\{
    \begin{array}{l r l}
      \begin{aligned}
      \{
      (x+1, 2\left\lfloor\frac{y}{3}\right\rfloor-2), \\
      (x, 2\left\lfloor\frac{y}{3}\right\rfloor-1)
      \}
      \end{aligned} & \mbox{dla } y=3n, & n\in\mathbb{Z} \\[30pt]
      \begin{aligned}
        \{
        (x, 2\left\lfloor\frac{y}{3}\right\rfloor-1), \\
        (x, 2\left\lfloor\frac{y}{3}\right\rfloor)
        \}
      \end{aligned} & y=3n+1, & n\in\mathbb{Z} \\[30pt]
      \begin{aligned}
      \{
      (x, 2\left\lfloor\frac{y}{3}\right\rfloor+1), \\
      (x, 2\left\lfloor\frac{y}{3}\right\rfloor)
      \}
      \end{aligned} & y=3n+2, & n\in\mathbb{Z} \\
    \end{array} \right.
  \label{edgenodes}
\end{equation}
\begin{equation}
  \text{edges}_{adj}(\text{edge}_{x,y})=
  \left\{
    \begin{array}{l r@{,~} l}
      \begin{aligned}
        \{
        (x+1, y-2), \\
        (x+1, y-1), \\
        (x, y+1), \\
        (x, y-1)
        \}
      \end{aligned} & \mbox{dla } y=3n & n\in\mathbb{Z} \\[40pt]
      \begin{aligned}
        \{
        (x-1, y+2), \\
        (x, y-2), \\
        (x, y-1), \\
        (x, y+1)
        \}
      \end{aligned} & y=3n+1 & n\in\mathbb{Z} \\[40pt]
      \begin{aligned}
        \{
        (x-1, y+1), \\
        (x, y-1), \\
        (x, y+2), \\
        (x, y+1)
        \}
      \end{aligned} & y=3n+2 & n\in\mathbb{Z} \\
    \end{array} \right.
  \label{edgeedges}
\end{equation}

\subsection{Gra}
Głównym zadaniem obiektów tej klasy będzie przechowywanie informacji o
stanie gry. Każda gra musi posiadać trzech lub czterech graczy oraz
planszę, na której toczy się rozgrywka. Ze względu na to, że przebieg
gry podzielony jest na etapy, a każdy z etapów składa się z wielu faz,
konieczne będzie zaimplementowanie maszyny stanowej. Dzięki maszynie
stanowej ,,fazy gry'', możliwe będzie sprawdzanie poprawności ruchów
wykonywanych przez graczy, oraz sterowanie przebiegiem gry.

\subsubsection{Maszyna stanowa ,,fazy gry''}
Gra ,,Osadnicy z Catanu'' podzielona jest na dwa etapy. Pierwszym
etapem gry jest etap zasiedlenia wyspy, podczas którego gracze kolejno
stawiają na planszy po jednej osadzie i drodze. Następnie każdy z
graczy stawia drugą osadę wraz z drogą, przy czym odbywa się to w
odwrotnej kolejności, tj. gracz który jako ostatni postawił swoją
pierwszą osadę, stawia drugą osadę jako pierwszy, itd.

Po etapie zasiedlenia wyspy następuje właściwy etap rozgrywki. Składa
się on z dwóch głównych faz - fazy przed rzutem kością oraz fazy po
rzucie.

\begin{itemize}
\item \texttt{first settlement} - faza budowania pierwszej osady, po
  wybudowaniu osady przechodzimy do fazy \texttt{first road}
\item \texttt{first road} - faza budowania pierwszej drogi. Jeśli
  istnieje gracz o numerze wyższym niż numer aktualnego gracza, to po
  wybudowaniu drogi przechodzimy do fazy \texttt{first settlement} W
  przeciwnym wypadku przechodzimy do \texttt{second settlement}
\item \texttt{second settlement} - faza budowania drugiej osady, po
  wybudowaniu osady przechodzimy do \texttt{second road}
\item \texttt{second road} - budowanie drugiej drogi. Jeśli istnieje
  gracz o numerze niższym niż numer aktualnego gracza, to po
  wybudowaniu drogi przechodzimy do fazy \texttt{second road}. W
  przeciwnym wypadku następuje przejście do fazy \texttt{before roll}
\item \texttt{before roll} - faza przed rzutem kością. Wykonując rzut
  kością, przenosimy się do fazy \texttt{after roll}. Jeśli wynik rzutu
  kością to 7, to przejście odbywa się poprzez fazy pośrednie - fazę
  \texttt{discard} oraz fazę \texttt{robber}. Przejście do fazy
  \texttt{discard} następuje wówczas, gdy jeden z graczy posiada więcej
  niż 7 kart surowców. Jeśli nie ma takiego gracza, to przechodzimy do
  fazy \texttt{robber}. Bezpośrednie przejście do fazy \texttt{robber}
  następuje również po zagraniu karty ,,rycerza''
\item \texttt{discard} - faza odrzucania nadmiarowych zasobów, w
  czasie której gracz ma obowiązek zredukować ilość posiadanych przez
  siebie kart zasobów do połowy, jeśli posiada ich więcej niż 7
  (nieparzysta ilość kart wymaga ,,zaokrąglenia'' na korzyść
  gracza). Faza ta jest powtarzana, dopóki wszyscy gracze nie pozbędą
  się nadmiarowych kart, po czym następuje przejście do fazy
  \texttt{robber}
\item \texttt{robber} - podczas tej fazy gry, należy przesunąć pionek
  ,,rozbójnika''. Po przesunięciu pionka następuje przejście do fazy
  \texttt{before roll} lub \texttt{after roll}, w zależności od tego,
  czy w aktualnej turze dokonano już rzutu kością
\item \texttt{after roll} - główna faza gry, podczas której gracz ma
  możliwość m.in. budowania osad, miast i dróg, kupowania kart rozwoju
  oraz zagrywania ich. Zagranie karty budowy drogi powoduje przejście
  do fazy \texttt{road building first road}. Możliwe jest także
  tworzenie ofert handlu z innymi graczami. Po stworzeniu oferty
  następuje przejście do fazy \texttt{offer}. Gracz w dowolnym momencie
  może zakończyć fazę \texttt{after roll}, co powoduje przejście do fazy
  \texttt{before roll}
\item \texttt{offer} - faza oferty handlu, podczas której gracz
  składający ofertę oczekuje na odpowiedzi innych. W każdej chwili
  może on zakończyć tę fazę powodując powrót do \texttt{after roll}
\item \texttt{road building first road} oraz \texttt{road building second
    road} - w każdej z faz gracz może wybudować po jednej darmowej
  drodze. Po wybudowaniu przynajmniej jednej z dróg następuje
  przejście do fazy \texttt{after roll}
\end{itemize}

Schemat przejść w maszynie stanowej fazy gry został przedstawiony na
\imref{statemachine-phase}.

\subsubsection{Maszyna stanowa ,,stanu gry''}

Dodatkowo, gra może znajdować się w jednym z następujących stanów:

\begin{itemize}
\item \emph{preparing} - początkowy stan, pozwalający na
  dołączanie się do gry nowych graczy. Przejście do stanu
  emph{playing} następuje po dołączeniu się przynajmniej trzech
  graczy, jeśli wszyscy z nich są gotowi do gry
\item \emph{playing} - gra znajdująca się w tym stanie została już
  rozpoczęta. Przejście do stanu \emph{ended} następuje po uzyskaniu
  przez jednego z graczy minimum 10 punktów zwycięstwa
\item \emph{ended} - końcowy stan oznaczający grę zakończoną
\end{itemize}

Do kontrolowania przejść pomiędzy powyższymi stanami gry, niezbędne
jest zaimplementowanie maszyny stanowej, której schemat został
przedstawiony na \imref{statemachine-state}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\linewidth]{statemachine-phase.pdf}
  \end{center}
  \caption{Maszyna stanowa fazy gry}
  \label{statemachine-phase}
\end{figure}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{statemachine-state.pdf}
  \end{center}
  \caption{Maszyna stanowa stanu gry}
  \label{statemachine-state}
\end{figure}

\subsection{Komunikacja}

Po przeanalizowaniu dostępnych rozwiązań, opisanych w rozdziale
\ref{javascript}, do komunikacji wybrany został \emph{HTTP
  Pull}. Opóźnienia, wynikające z zastosowania tego mechanizmu nie
mają większego wpływu na rozgrywkę. Istotnym elementem przemawiającym
za wykorzystaniem \emph{HTTP Pull} jest prostota użytkowania. Nie
wymusza on posiadania dodatkowych serwerów i domen. Ponadto, większość
dostępnych bibliotek \emph{JavaScriptowych} udostępnia wygodne
mechanizmy umożliwiające proste tworzenie wywołań \emph{Ajax}.

Jako format wymiany danych wybrany został \emph{JSON}. Główną zaletą
tego formatu jest fakt, że do parsowania zapisanych w nim danych, w
języku \emph{JavaScript} nie potrzeba żadnych dodatkowych
narzędzi\footnote{JSON (ang. JavaScript Object Notation) - prosty
  format wymiany danych. W związku z tym, że jego składnia opiera się
  o podzbiór języka \emph{JavaScript}, parsowanie go w tym języku
  ogranicza się do wykorzystania funkcji \texttt{eval}.}. \emph{JSON}
jest również jednym z głównych formatów serializacji danych, używanych
we frameworku \emph{Ruby on Rails}.

\subsection{Baza danych}
Główną tabelą w bazie danych, z którą w różnej liczebności łączą się
wszystkie pozostałe, jest tabela \texttt{games}. Oprócz opisywanej już
w \ref{sec:board} planszy (tabele \texttt{board}, \texttt{hexes},
\texttt{nodes} oraz \texttt{edges}), posiada ona kilka dodatkowych,
połączonych z nią tabel:

\begin{itemize}
\item \texttt{players} - zawiera informacje o graczach -
  posiadanych przez nich surowców, ilości punktów zwycięstwa, itp.
\item \texttt{dice\_rolls} - informacje wynikach rzutów
  kośćmi
\item \texttt{cards} - każda karta zawiera m.in informację o typie i
  graczu, który ją nabył
\item \texttt{offer} - przechowuje informacje o ofertach
\item \texttt{offer\_responses} - informacje o odpowiedziach na oferty
\item \texttt{discards} - informacje o odrzuconych kartach zasobów
\item \texttt{robberies} - informacja o pozycji, na którą został
  przesunięty pionek ,,rozbójnika'', a także o zagrabionych zasobach
\item \texttt{exchanges} - zawiera informacje o handlu graczy z
  bankiem
\end{itemize}

Uproszczony diagram związków encji projektowanej bazy danych został
przedstawiony na \imref{erd}. W związku z tym, że rekordy w
wymienionych wyżej tabeli są dodawane przez poszczególnych graczy,
większość z nich zawiera także powiązanie z graczem. W przypadku
m.in. ofert, konieczne jest przechowanie informacji o obu uczestnikach
transakcji (dwa powiązania z tabelą \texttt{players}). Niektóre
informacje przechowywane w bazie danych wydają się być nieco
nadmiarowe, mogą one jednak posłużyć do wygenerowania obszernych
statystyk po zakończeniu rozgrywki (np. statystyka wyników rzutów
kośćmi).

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\linewidth]{erd.pdf}
  \end{center}
  \caption{Uproszczony diagram związków encji}
  \label{erd}
\end{figure}

\clearpage

\section{Implementacja serwera}

\subsection{Modele}

\subsubsection{Gra}
Model \texttt{Game} jest głównym elementem kontrolującym przebieg
rozgrywki. Posiada on implementację dwóch maszyn stanowych
przedstawionych na \imref{statemachine-state} i
\imref{statemachine-phase}. Do implementacji maszyn stanowych
wykorzystana została biblioteka \texttt{state\_machine}, stworzona
przez Aarona Pfeifera. Udostępnia ona bardzo prosty
\emph{DSL}\footnote{DSL (ang. Domain-specific language) - język
  dziedzinowy, przystosowany do rozwiązywania określonej dziedziny
  problemów} służący do opisu stanów i przejść pomiędzy nimi. Kod
maszyny stanowej stanu gry został przedstawiony na listingu
\ref{listing:statemachine}.

\begin{listing}
  \input{statemachine}
  \caption{Maszyna stanowa stanu gry}
  \label{listing:statemachine}
\end{listing}

Początkowym stanem jest stan \texttt{preparing}.  Maszyna ta posiada
dwa zdarzenia: \texttt{start\_game} i \texttt{end\_game}, powodujące
przejścia do stanów \texttt{playing} oraz \texttt{ended}. Każde
przejście może posiadać także proste warunki, które muszą zostać
spełnione aby możliwa była zmiana stanu. W przypadku zdarzenia
\texttt{end\_game} i przejścia z \texttt{playing} do \texttt{ended},
metoda \texttt{winner?} musi zwrócić prawdę (dzieje się tak w
przypadku, gdy zwycięzca gry jest już znany). Dodatkowo każdy z
wymienionych stanów może posiadać własne zestawy walidatorów. Aby
można było zapisać obiekt w stanie \texttt{playing}, spełnione muszą
zostać trzy warunki:

\begin{itemize}
\item gra musi posiadać 3-4 graczy
\item gra musi posiadać wygenerowaną planszę do gry
\item wszyscy gracze muszą być gotowi do gry
\end{itemize}

Każde zdarzenie może posiadać również zestaw funkcji, które należy
wywołać przed lub po zmianie stanów (\texttt{before\_transition} i
\texttt{after\_transition}).

Implementacja maszyny stanowej ,,fazy gry'', przedstawionej na
\imref{statemachine-phase}, jest nieco bardziej
skomplikowana. Sytuacja ta wynika z faktu, iż w przypadku wielu
zdarzeń mamy zdefiniowane wiele różnych przejść. Wybór konkretnej
ścieżki zależny jest zarówno od fazy gry, jak i pozostałych atrybutów
określających jej stan (np. numer aktualnego gracza). W przypadku
zbudowania przez gracza drogi (zdarzenie \texttt{road\_built}) mamy do
dyspozycji następujące przejścia:

\begin{itemize}
\item z \texttt{first\_road} do \texttt{first\_settlement} - przejście
  możliwe tylko wówczas, gdy istnieje gracz o numerze wyższym od
  numeru aktualnego gracza. Jeśli warunek nie jest spełniony,
  wybierane jest bezwarunkowe przejście do \texttt{second\_settlement}
\item z \texttt{second\_road} do \texttt{second\_settlement} -
  analogicznie jak w poprzednim przypadku, przejście jest możliwe tylko
  jeśli istnieje gracz o numerze niższym od numeru aktualnego
  gracza. W przeciwnym wypadku wybierane jest bezwarunkowe przejście
  do \texttt{before\_roll}
\item z \texttt{road\_building\_first\_road} do
  \texttt{road\_building\_second\_road} - bezwarunkowo
\item z \texttt{road\_building\_second\_road} do \texttt{after\_roll}
  - bezwarunkowo
\item z \texttt{after\_roll} do \texttt{after\_roll} - bezwarunkowo
\end{itemize}

Gdyby nie fakt, iż obiekt gry jest odpowiedzialny za sprawdzanie
poprawności wywoływanych zdarzeń, to ostatnie z opisywanych przejść
nie miałoby większego sensu. W większości przypadków weryfikacja
zdarzenia polega na sprawdzeniu, czy aktualna tura jest turą
użytkownika, który wywołał zdarzenie (lub czy dany użytkownik w ogóle
uczestniczy w rozgrywce). Dodatkowo sprawdzany jest stan gry - jeśli
gra się jeszcze nie rozpoczęła (stan \texttt{preparing}) lub została
już zakończona (stan \texttt{ended}), to nie jest możliwa zmiana fazy
gry. Fragment kodu źródłowego maszyny stanowej ,,fazy gry'' został
przedstawiony na listingu \ref{listing:statemachine-phase}.

\begin{listing}
  \input{statemachine-phase}
  \caption{Maszyna stanowa fazy gry}
  \label{listing:statemachine-phase}
\end{listing}

Uproszczony algorytm wyboru przejść w maszynie stanowej opartej na
bibliotece \texttt{state\_machine} jest następujący:

\begin{enumerate}
\item wybieramy z listy przejść pierwsze, które rozpoczyna się w
  aktualnym stanie (jeśli w danym zdarzeniu nie ma przejść
  rozpoczynających się w aktualnym stanie - kończymy
  algorytm) \label{selectfirst}
\item sprawdzamy, czy warunki przejścia (parametry \texttt{:if} i
  \texttt{:unless}) są spełnione\label{checkconditions}. Jeśli tak, to
  próbujemy wykonać przejście zgodnie z punktem \ref{callbacks}. W
  przeciwnym wypadku wybieramy kolejne przejście, które rozpoczyna się
  w aktualnym stanie i wykonujemy ponownie punkt \ref{checkconditions}
  (jeśli nie ma przejścia, to kończymy algorytm)
\item sprawdzamy rezultaty wywołań zwrotnych (ang. callbacks)
  przypisanych przez \texttt{before\_transition}. Jeśli którekolwiek z
  nich zwróci wartość \texttt{false}, to nie dokonujemy zmiany stanu i
  kończymy algorytm. W przeciwnym wypadku wykonujemy zmianę stanu
  wynikającą z wybranego przejścia, zapisujemy zmieniony obiekt w
  bazie danych i wywołujemy funkcje przypisane przez
  \texttt{after\_transition} \label{callbacks}
\end{enumerate}

Maszyna stanowa ,,fazy gry'' posiada zdefiniowany zestaw zdarzeń,
wywoływanych w następujących sytuacjach:

\begin{itemize}
\item \texttt{settlement\_built} - wybudowana została osada (lub miasto)
\item \texttt{road\_built} - wybudowana została droga
\item \texttt{dice\_rolled} - wykonano rzut kośćmi
\item \texttt{discarded} - odrzucono nadmiarowe karty surowców
\item \texttt{robbed} - pionek ,,rozbójnika'' został przesunięty
\item \texttt{end\_turn} - tura została zakończona
\item \texttt{card\_bought} - została zakupiona karta rozwoju
\item \texttt{army\_card\_played} - zagrano kartę ,,rycerza'' (armii)
\item \texttt{road\_building\_card\_played} - zagrano kartę ,,budowy
  dróg''
\item \texttt{card\_played} - zagrano kartę rozwoju ,,monopol'' lub
  ,,wynalazek''
\item \texttt{end\_road\_building} - zakończono budowę dróg po
  zagraniu karty
\item \texttt{offer\_created} - stworzono ofertę handlu
\item \texttt{offer\_expired} - oferta handlu wygasła (została
  zaakceptowana lub odwołana)
\item \texttt{exchanged} - dokonano wymiany surowców z bankiem
\end{itemize}

Do przechowywania stanu opisywanych maszyn stanowych, służą kolumny
\texttt{state} i \texttt{phase}. W kolumnach tych zapisywane są nazwy
stanów w postaci ciągu znaków\footnote{nic nie stoi na przeszkodzie,
  aby w razie problemów wydajnościowych, stany były przechowywane w
  postaci liczbowej. Do tego celu można wykorzystać bibliotekę
  \emph{enumerate\_by}, stworzoną przez Aarona Pfeifera}. Oprócz
stanów, konieczne jest przechowanie szeregu dodatkowych informacji o
rozgrywce, m.in.:

\begin{itemize}
\item aktualnym graczu (kolumna \texttt{current\_player\_id})
\item aktualnym graczu, który musi odrzucić surowce. Przechowanie tej
  informacji jest konieczne, gdyż faza odrzucenia surowców przez
  gracza o numerze 1 może nastąpić po wyrzuceniu 7 oczek przez gracza
  o numerze 2, podczas trwania jego tury (kolumna
  \texttt{current\_discard\_player\_id})
\item najdłuższej drodze i największej armii, oraz graczach, które są
  w ich posiadaniu (kolumny \texttt{longest\_road\_length},
  \texttt{longest\_road\_player\_id}, \texttt{largest\_army\_size}
  oraz \texttt{largest\_army\_player\_id})
\item pozostałej ilości i rodzaju kart, które mogą zostać zakupione
  przez graczy (\texttt{army\_cards}, \texttt{monopoly\_cards},
  \texttt{year\_of\_plenty\_cards}, \texttt{road\_building\_cards},
  \texttt{victory\_point\_cards})
\item karcie, która została zagrana w bieżącej turze (\texttt{card\_id})
\item numerze tury (\texttt{current\_turn})
\end{itemize}

\subsubsection{Plansza}

Model \texttt{Board} odpowiedzialny jest za tworzenie i walidację
powiązanych z nim sześciokątów. Przed zapisaniem obiektu planszy do
bazy danych, tworzone są powiązane z nią sześciokąty, na podstawie
informacji zawartych w atrybucie
\texttt{hexes\_attributes}. Dodatkowymi atrybutami obiektu
\texttt{board} są rozmiar (\texttt{size}) i początkowa pozycja
,,rozbójnika'' (\texttt{robber\_position}). Sposób tworzenia
przykładowej planszy do gry został przedstawiony na listingu
\ref{listing:board}.

\begin{listing}
  \input{board}
  \caption{Tworzenie przykładowej planszy do gry}
  \label{listing:board}
\end{listing}

Rozmiar planszy jest przechowywany w kolumnach \texttt{height} i
\texttt{width}, pozycja ,,rozbójnika'' w \texttt{robber\_row} i
\texttt{robber\_col}. Każda plansza posiada identyfikator gry, do
której należy, przechowywany w kolumnie \texttt{game\_id}.

\subsubsection{Sześciokąt}
Zadaniem modelu \texttt{Hex} jest przechowywanie informacji o
sześciokątach znajdujących się na planszy do gry. Każdy z nich posiada
określony typ (\texttt{hex\_type}), tj. \texttt{hill}, \texttt{field},
\texttt{mountain}, \texttt{pasture}, \texttt{forest}, \texttt{desert}
lub \texttt{sea}. W zależności od typu, może on także posiadać
atrybuty takie jak:

\begin{itemize}
\item \texttt{roll} - przyporządkowany wynik rzutu kośćmi, będący
  liczbą z zakresu 2-12, z wyłączeniem liczby 7
\item \texttt{harbor\_position} - numer krawędzi, przy której
  wybudowane osady stają się portami, liczba z zakresu 0-5
\item \texttt{harbor\_type} - rodzaj szlaku handlowego, znajdującego
  się na sześciokącie. Atrybut jest wymagany, jeśli sześciokąt posiada
  zdefiniowaną pozycję portu, musi to być jedna z wartości:
  \texttt{bricks}, \texttt{grain}, \texttt{lumber}, \texttt{ore},
  \texttt{wool} lub \texttt{generic}
\end{itemize}

Każdy sześciokąt posiada zdefiniowaną pozycję, przechowywaną w
kolumnach \texttt{row} i \texttt{col}, oraz identyfikator planszy, do
której należy (kolumna \texttt{board\_id}). Na podstawie wzorów
przedstawionych w rozdziale \ref{sec:calculations} i pozycji
sześciokąta, możliwe stało się zdefiniowanie metody
\texttt{hex\_positions}, przedstawionej na listingu
\ref{listing:hex}. Metoda ta zwraca tablicę pozycji sześciokątów
sąsiadujących z sześciokątem, na którym została wywołana. Dzięki
metodzie klasowej \texttt{find\_by\_positions} możliwe jest
przekształcenie listy pozycji, na listę odpowiadających im
sześciokątów. Obiekty te wyciągane są z bazy danych pojedynczym
zapytaniem, którego przykład został przedstawiony na listingu
\ref{listing:find}. Analogicznie zaimplementowane zostały metody,
wyciągające z bazy danych sąsiadujące z sześciokątem wierzchołki i
krawędzie.

\begin{listing}
  \input{hex}
  \caption{Wyciąganie sąsiadujących sześciokątów}
  \label{listing:hex}
\end{listing}

\begin{listing}
  \input{find}
  \caption{Przykładowe zapytanie \emph{SQL}}
  \label{listing:find}
\end{listing}

\subsubsection{Wierzchołek}

Wierzchołki reprezentowane są przez obiekty klasy \texttt{Node}. Są
one tworzone dopiero wówczas, gdy jeden z graczy buduje osadę na
wybranej przez siebie pozycji. Nie ma potrzeby tworzenia
,,niezasiedlonych'' wierzchołków, co znacznie przyspiesza generowanie
planszy oraz ogranicza ilość koniecznych do przechowania
informacji. Każdy wierzchołek musi posiadać właściciela,
tj. identyfikator gracza, do którego należy (kolumna
\texttt{player\_id}), identyfikator planszy na której się znajduje
(\texttt{board\_id}) oraz pozycję (kolumny \texttt{row} i
\texttt{col}). W związku z tym, że zasiedlony wierzchołek może być
,,osadą'' lub ,,miastem'', konieczne jest przechowanie stanu, w jakim
się znajduje. W tym celu zaimplementowana została prosta maszyna
stanowa przedstawiona na listingu \ref{listing:node}.

\begin{listing}
  \input{node}
  \caption{Maszyna stanowa wierzchołka}
  \label{listing:node}
\end{listing}

Początkowy stan maszyny stanowej wierzchołka to \texttt{nil}. Możemy z
niego przejść wyłącznie do stanu \texttt{settlement}. Taka konstrukcja
uniemożliwia stworzenie nowego wierzchołka w stanie \texttt{city}, co
byłoby możliwe przy stanie początkowym \texttt{settlement}
odpowiedniej manipulacji atrybutem
\texttt{state\_event}\footnote{atrybut \texttt{state\_event} służy do
  wywoływania zdarzenia maszyny stanowej przy aktualizacji innych
  atrybutów, np. z poziomu formularza na stronie. Element ten zostanie
  dokładniej omówiony przy opisywaniu zasobów \emph{REST}}.

Przy tworzeniu ,,osady'' przez gracza, sprawdzane są następujące
elementy:

\begin{itemize}
\item obecność planszy - nie można stworzyć wierzchołka niepowiązanego
  z planszą
\item obecność gracza - każdy wierzchołek musi posiadać właściciela
\item obecność stanu - wierzchołek musi znajdować się w jednym ze
  stanów: \texttt{settlement} lub \texttt{city}
\item unikalność pozycji w obrębie planszy - na jednej planszy nie
  mogą znajdować się dwa wierzchołki o tej samej pozycji
\item obecność ,,lądu'' w sąsiadujących sześciokątach - każdy
  wierzchołek musi sąsiadować co najmniej z jednym sześciokątem, który
  nie jest ,,morzem''
\item obecność innych wierzchołków w sąsiedztwie - jeśli jeden z
  sąsiadujących wierzchołków został już zasiedlony, to pozycja
  budowanej osady nie jest prawidłowa
\item obecność drogi - przynajmniej jedna sąsiadująca krawędź musi być
  ,,zasiedlona'' przez gracza, który buduje osadę\footnote{ten warunek
    nie musi być spełniony w pierwszym etapie gry, tzn. podczas
    zasiedlania wyspy}
\end{itemize}

W przypadku rozbudowy ,,osady'' sprawdzane jest także, czy nie został
zmieniony właściciel wierzchołka. Konieczne jest również sprawdzenie,
czy gracz posiada wystarczającą ilość kart surowców, osad i
miast. Odbywa się to poprzez modyfikację obiektu gracza i sprawdzenie,
czy w dalszym ciągu spełnia on warunki walidacji (gracz nie może
posiadać np. ujemnej ilości ,,cegieł''). Jeśli osada jest ,,portem'',
tzn. wybudowana została przy szlaku handlowym, to zmieniane są również
odpowiednie kursy wymian w obiekcie gracza. Jeżeli wszystkie
wymienione warunki zostały spełnione, to obiekt jest zapisywany w
bazie danych i wywoływane jest zdarzenie \texttt{settlement\_built!} w
maszynie stanowej ,,fazy gry''. Jako parametr tego wywołania
przekazywany jest obiekt użytkownika, właściciela wierzchołka. W
przypadku, gdy wywołane zdarzenie jest nieprawidłowe rzucany jest
wyjątek. Dzięki temu, że wszystkie operacje bazodanowe, wykonywane
przed lub po zapisie właściwego obiektu, są objęte jedną transakcją,
to po rzuceniu wyjątku baza danych nie jest w żaden sposób
modyfikowana, a transakcja zostaje wycofana
(ang. \emph{rollback}). Taki mechanizm zapewnia, że wszystkie akcje
graczy muszą być wywoływane wyłącznie w przeznaczonych dla nich fazach
gry.

\subsubsection{Krawędź}



\subsubsection{Gracz}
\subsubsection{Karta rozwoju}
\subsubsection{Rzut kością}
\subsubsection{Odrzucenie zasobów}
\subsubsection{Wymiana z bankiem}
\subsubsection{Oferta handlu}
\subsubsection{Odpowiedź na ofertę handlu}
\subsubsection{Rabunek}
\subsubsection{Użytkownik}
\subsubsection{Sesja użytkownika}

\subsection{Kontrolery}

\subsection{Widoki}

\clearpage

\section{Implementacja klienta}


\clearpage

\bibliographystyle{plain}
\bibliography{praca}

\end{document}
